<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Herramienta de Medición de Productos - ArelyShop</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f1f5f9; /* slate-100 */
        }
        /* Estilos para el contenedor del canvas */
        #canvas-container {
            width: 100%;
            max-width: 600px; /* Tamaño máximo en escritorio */
            aspect-ratio: 1 / 1;
            border: 3px dashed #cbd5e1; /* slate-300 */
            transition: border-color 0.3s, background-color 0.3s;
        }
        #canvas-container.drag-over {
            border-color: #3b82f6; /* blue-500 */
            background-color: #eff6ff; /* blue-50 */
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        /* Estilos para la paleta de colores */
        .color-swatch {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid transparent;
            transition: border-color 0.2s;
        }
        .color-swatch.selected {
            border-color: #3b82f6; /* blue-500 */
            box-shadow: 0 0 0 2px white;
        }
        /* Estilos para el modal de entrada de texto */
        #modal {
            background-color: rgba(0, 0, 0, 0.5);
        }
    </style>
</head>
<body class="min-h-screen flex flex-col">

    <!-- Header proporcionado por el usuario -->
    <header class="bg-slate-900 p-4 shadow-md">
        <div class="max-w-4xl mx-auto flex justify-center" bis_skin_checked="1">
            <img src="https://dcdn-us.mitiendanube.com/stores/004/546/736/themes/common/logo-660776128-1736645739-9bb5db1715d3b799cdf782b0f0815d541736645739.webp?0" alt="Logo ArelyShop" class="h-12" onerror="this.onerror=null; this.src='https://placehold.co/200x50/0f172a/ffffff?text=ArelyShop';">
        </div>
    </header>

    <!-- Contenido principal de la aplicación -->
    <main class="flex-grow container mx-auto p-4 md:p-8 flex flex-col items-center">
        
        <div class="w-full max-w-4xl flex flex-col lg:flex-row gap-8">
            <!-- Columna de Controles -->
            <div class="w-full lg:w-1/3 space-y-6">
                <div class="bg-white p-6 rounded-lg shadow-md">
                    <h2 class="text-xl font-bold text-slate-800 mb-4">1. Cargar Imagen</h2>
                    <p class="text-sm text-slate-500 mb-4">Arrastra un archivo o súbelo desde tu equipo.</p>
                    <label for="image-loader" class="w-full inline-block text-center bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 transition cursor-pointer">
                        Seleccionar Foto
                    </label>
                    <input type="file" id="image-loader" class="hidden" accept="image/*">
                </div>

                <div class="bg-white p-6 rounded-lg shadow-md">
                    <h2 class="text-xl font-bold text-slate-800 mb-4">2. Elegir Color</h2>
                    <p class="text-sm text-slate-500 mb-4">Selecciona un color para las líneas de medida.</p>
                    <div id="color-palette" class="flex justify-center gap-4">
                        <div class="color-swatch selected" style="background-color: #000000;" data-color="#000000"></div>
                        <div class="color-swatch" style="background-color: #ef4444;" data-color="#ef4444"></div>
                        <div class="color-swatch" style="background-color: #3b82f6;" data-color="#3b82f6"></div>
                        <div class="color-swatch" style="background-color: #22c55e;" data-color="#22c55e"></div>
                        <div class="color-swatch" style="background-color: #f97316;" data-color="#f97316"></div>
                    </div>
                </div>

                <div class="bg-white p-6 rounded-lg shadow-md">
                    <h2 class="text-xl font-bold text-slate-800 mb-4">3. Descargar</h2>
                    <p class="text-sm text-slate-500 mb-4">Guarda la imagen final con las medidas (1000x1000px).</p>
                    <button id="download-btn" class="w-full bg-emerald-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-emerald-700 transition disabled:bg-slate-400 disabled:cursor-not-allowed" disabled>
                        Descargar Imagen
                    </button>
                </div>
                 <div class="bg-white p-6 rounded-lg shadow-md">
                    <h2 class="text-xl font-bold text-slate-800 mb-4">4. Reiniciar</h2>
                     <p class="text-sm text-slate-500 mb-4">Borra todas las medidas o haz clic en la 'X' de una medida para eliminarla.</p>
                    <button id="reset-btn" class="w-full bg-red-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-700 transition disabled:bg-slate-400 disabled:cursor-not-allowed" disabled>
                        Borrar Medidas
                    </button>
                </div>
            </div>

            <!-- Columna del Canvas -->
            <div class="w-full lg:w-2/3 flex flex-col items-center">
                <div id="canvas-container" class="bg-white rounded-lg shadow-md flex items-center justify-center relative">
                    <canvas id="canvas" width="1000" height="1000"></canvas>
                    <div id="placeholder-text" class="absolute text-center text-slate-400 p-4 pointer-events-none">
                        <p class="text-lg font-semibold">Arrastra y suelta una imagen aquí</p>
                        <p class="text-sm">o usa el botón "Seleccionar Foto"</p>
                    </div>
                </div>
            </div>
        </div>

    </main>

    <!-- Modal para ingresar la medida -->
    <div id="modal" class="fixed inset-0 z-50 items-center justify-center hidden">
        <div class="bg-white p-6 rounded-lg shadow-xl w-80">
            <h3 class="text-lg font-bold mb-4">Ingresar Medida</h3>
            <input type="text" id="measurement-input" class="w-full border border-slate-300 rounded-md p-2 mb-4" placeholder="Ej: 25 cm">
            <div class="flex justify-end gap-2">
                <button id="cancel-btn" class="px-4 py-2 bg-slate-200 text-slate-800 rounded-md hover:bg-slate-300">Cancelar</button>
                <button id="submit-btn" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700">Aceptar</button>
            </div>
        </div>
    </div>

    <script>
        // --- ELEMENTOS DEL DOM ---
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const imageLoader = document.getElementById('image-loader');
        const downloadBtn = document.getElementById('download-btn');
        const resetBtn = document.getElementById('reset-btn');
        const canvasContainer = document.getElementById('canvas-container');
        const placeholderText = document.getElementById('placeholder-text');
        const colorPalette = document.getElementById('color-palette');
        const modal = document.getElementById('modal');
        const measurementInput = document.getElementById('measurement-input');
        const submitBtn = document.getElementById('submit-btn');
        const cancelBtn = document.getElementById('cancel-btn');

        // --- ESTADO DE LA APLICACIÓN ---
        let image = null;
        let measurements = [];
        let isDrawing = false;
        let startX, startY, endX, endY;
        let currentColor = '#000000';
        // *** NUEVO: Estado para detectar hover y eliminación ***
        let hoveredMeasurementIndex = -1;
        
        // --- CONSTANTES DE CONFIGURACIÓN ---
        const CANVAS_WIDTH = 1000;
        const CANVAS_HEIGHT = 1000;
        const TEXT_SIZE = 30;
        const LINE_WIDTH = 3;
        const CAP_LENGTH = 15;
        const DELETE_BUTTON_RADIUS = 15;

        // --- INICIALIZACIÓN ---
        function init() {
            setupEventListeners();
            clearCanvas();
        }

        function setupEventListeners() {
            imageLoader.addEventListener('change', handleImageUpload);
            canvasContainer.addEventListener('dragover', handleDragOver);
            canvasContainer.addEventListener('dragleave', handleDragLeave);
            canvasContainer.addEventListener('drop', handleDrop);
            
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseleave', handleMouseLeave);
            // *** NUEVO: Evento de clic para manejar la eliminación ***
            canvas.addEventListener('click', handleClick);

            downloadBtn.addEventListener('click', downloadImage);
            resetBtn.addEventListener('click', resetMeasurements);
            colorPalette.addEventListener('click', selectColor);

            submitBtn.addEventListener('click', submitMeasurement);
            cancelBtn.addEventListener('click', cancelMeasurement);
            measurementInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') submitMeasurement();
                if (e.key === 'Escape') cancelMeasurement();
            });
        }

        // --- MANEJO DE IMAGEN ---
        function handleImageUpload(e) {
            const file = e.target.files[0];
            if (file) loadImage(file);
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.stopPropagation();
            canvasContainer.classList.add('drag-over');
        }

        function handleDragLeave(e) {
            e.preventDefault();
            e.stopPropagation();
            canvasContainer.classList.remove('drag-over');
        }

        function handleDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            canvasContainer.classList.remove('drag-over');
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('image/')) loadImage(file);
        }

        function loadImage(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                image = new Image();
                image.onload = () => {
                    measurements = [];
                    enableButtons();
                    redrawCanvas();
                };
                image.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
        
        function enableButtons() {
            downloadBtn.disabled = false;
            resetBtn.disabled = false;
            placeholderText.style.display = 'none';
        }

        // --- LÓGICA DE DIBUJO, HOVER Y CLIC ---
        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (e.clientX - rect.left) * (CANVAS_WIDTH / rect.width),
                y: (e.clientY - rect.top) * (CANVAS_HEIGHT / rect.height)
            };
        }

        function handleMouseDown(e) {
            if (!image || hoveredMeasurementIndex !== -1) return; // No empezar a dibujar si el cursor está sobre un botón de eliminar
            isDrawing = true;
            const pos = getMousePos(e);
            startX = pos.x;
            startY = pos.y;
        }

        function handleMouseMove(e) {
            const pos = getMousePos(e);
            if (isDrawing) {
                let currentX = pos.x;
                let currentY = pos.y;
                if (e.shiftKey) {
                    const dx = Math.abs(currentX - startX);
                    const dy = Math.abs(currentY - startY);
                    if (dx > dy) currentY = startY;
                    else currentX = startX;
                }
                endX = currentX;
                endY = currentY;
                redrawCanvas();
                drawMeasurementLine({startX, startY, endX, endY, color: currentColor});
            } else {
                // *** Lógica de HOVER ***
                let newHoverIndex = -1;
                for (let i = measurements.length - 1; i >= 0; i--) {
                    const m = measurements[i];
                    const buttonPos = getDeleteButtonPosition(m);
                    const distToButton = Math.hypot(pos.x - buttonPos.x, pos.y - buttonPos.y);
                    if (distToButton <= DELETE_BUTTON_RADIUS) {
                        newHoverIndex = i;
                        break;
                    }
                    const distToLine = pointToLineSegmentDistance(pos.x, pos.y, m.startX, m.startY, m.endX, m.endY);
                    if (distToLine < 10) {
                        newHoverIndex = i;
                        break;
                    }
                }
                if (newHoverIndex !== hoveredMeasurementIndex) {
                    hoveredMeasurementIndex = newHoverIndex;
                    canvas.style.cursor = hoveredMeasurementIndex !== -1 ? 'pointer' : 'crosshair';
                    redrawCanvas();
                }
            }
        }

        function handleMouseUp() {
            if (!isDrawing) return;
            isDrawing = false;
            if (startX !== endX || startY !== endY) {
                showModal();
            }
        }
        
        function handleMouseLeave() {
            if (isDrawing) {
                isDrawing = false;
                redrawCanvas();
            }
            if(hoveredMeasurementIndex !== -1) {
                hoveredMeasurementIndex = -1;
                canvas.style.cursor = 'crosshair';
                redrawCanvas();
            }
        }

        function handleClick(e) {
            if (hoveredMeasurementIndex !== -1) {
                const pos = getMousePos(e);
                const m = measurements[hoveredMeasurementIndex];
                const buttonPos = getDeleteButtonPosition(m);
                const dist = Math.hypot(pos.x - buttonPos.x, pos.y - buttonPos.y);

                if (dist <= DELETE_BUTTON_RADIUS) {
                    measurements.splice(hoveredMeasurementIndex, 1);
                    hoveredMeasurementIndex = -1;
                    canvas.style.cursor = 'crosshair';
                    redrawCanvas();
                }
            }
        }

        function pointToLineSegmentDistance(px, py, x1, y1, x2, y2) {
            const l2 = (x2 - x1) ** 2 + (y2 - y1) ** 2;
            if (l2 === 0) return Math.hypot(px - x1, py - y1);
            let t = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / l2;
            t = Math.max(0, Math.min(1, t));
            const closestX = x1 + t * (x2 - x1);
            const closestY = y1 + t * (y2 - y1);
            return Math.hypot(px - closestX, py - closestY);
        }

        // --- MODAL ---
        function showModal() {
            modal.style.display = 'flex';
            measurementInput.value = '';
            measurementInput.focus();
        }

        function hideModal() {
            modal.style.display = 'none';
        }

        function submitMeasurement() {
            const text = measurementInput.value.trim();
            if (text) {
                measurements.push({ startX, startY, endX, endY, color: currentColor, text });
            }
            hideModal();
            redrawCanvas();
        }

        function cancelMeasurement() {
            hideModal();
            redrawCanvas();
        }

        // --- FUNCIONES DE RENDERIZADO ---
        function clearCanvas() {
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
             if (!image) {
                placeholderText.style.display = 'block';
                canvas.style.cursor = 'default';
            } else {
                 canvas.style.cursor = hoveredMeasurementIndex !== -1 ? 'pointer' : 'crosshair';
            }
        }
        
        function redrawCanvas() {
            clearCanvas();
            if (image) {
                const hRatio = CANVAS_WIDTH / image.width;
                const vRatio = CANVAS_HEIGHT / image.height;
                const ratio = Math.min(hRatio, vRatio);
                const centerShiftX = (CANVAS_WIDTH - image.width * ratio) / 2;
                const centerShiftY = (CANVAS_HEIGHT - image.height * ratio) / 2;
                ctx.drawImage(image, 0, 0, image.width, image.height, centerShiftX, centerShiftY, image.width * ratio, image.height * ratio);
            }
            measurements.forEach((m, index) => {
                drawMeasurementLine(m, index);
            });
        }

        function getDeleteButtonPosition(m) {
             const angle = Math.atan2(m.endY - m.startY, m.endX - m.startX);
             const perpAngle = angle + Math.PI / 2;
             // Posicionar el botón un poco más allá del final de la línea
             return {
                x: m.endX + (CAP_LENGTH + 5) * Math.cos(perpAngle),
                y: m.endY + (CAP_LENGTH + 5) * Math.sin(perpAngle)
             }
        }

        function drawMeasurementLine(m, index) {
            const { startX, startY, endX, endY, color, text = '' } = m;
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = (index === hoveredMeasurementIndex) ? LINE_WIDTH + 2 : LINE_WIDTH; // Resaltar línea en hover
            ctx.font = `bold ${TEXT_SIZE}px Inter`;
            
            const angle = Math.atan2(endY - startY, endX - startX);
            const perpAngle = angle + Math.PI / 2;

            const cap1_x1 = startX + CAP_LENGTH * Math.cos(perpAngle);
            const cap1_y1 = startY + CAP_LENGTH * Math.sin(perpAngle);
            const cap1_x2 = startX - CAP_LENGTH * Math.cos(perpAngle);
            const cap1_y2 = startY - CAP_LENGTH * Math.sin(perpAngle);
            
            const cap2_x1 = endX + CAP_LENGTH * Math.cos(perpAngle);
            const cap2_y1 = endY + CAP_LENGTH * Math.sin(perpAngle);
            const cap2_x2 = endX - CAP_LENGTH * Math.cos(perpAngle);
            const cap2_y2 = endY - CAP_LENGTH * Math.sin(perpAngle);

            ctx.beginPath();
            if (text) {
                const textMetrics = ctx.measureText(text);
                const textWidth = textMetrics.width + 10;
                const lineLength = Math.hypot(endX - startX, endY - startY);
                const segmentLength = (lineLength - textWidth) / 2;
                if (segmentLength > 0) {
                    const gapStartX = startX + segmentLength * Math.cos(angle);
                    const gapStartY = startY + segmentLength * Math.sin(angle);
                    const gapEndX = endX - segmentLength * Math.cos(angle);
                    const gapEndY = endY - segmentLength * Math.sin(angle);
                    ctx.moveTo(startX, startY); ctx.lineTo(gapStartX, gapStartY);
                    ctx.moveTo(gapEndX, gapEndY); ctx.lineTo(endX, endY);
                }
            } else {
                ctx.moveTo(startX, startY); ctx.lineTo(endX, endY);
            }
            ctx.moveTo(cap1_x1, cap1_y1); ctx.lineTo(cap1_x2, cap1_y2);
            ctx.moveTo(cap2_x1, cap2_y1); ctx.lineTo(cap2_x2, cap2_y2);
            ctx.stroke();

            if (text) {
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;
                ctx.save();
                ctx.translate(midX, midY);
                ctx.rotate(angle);
                if (angle > Math.PI / 2 || angle < -Math.PI / 2) ctx.rotate(Math.PI);
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(text, 0, 0); 
                ctx.restore();
            }

            // *** DIBUJAR BOTÓN DE ELIMINAR ***
            if (index === hoveredMeasurementIndex) {
                const buttonPos = getDeleteButtonPosition(m);
                ctx.beginPath();
                ctx.arc(buttonPos.x, buttonPos.y, DELETE_BUTTON_RADIUS, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(239, 68, 68, 0.9)'; // red-500 con transparencia
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(buttonPos.x - 6, buttonPos.y - 6);
                ctx.lineTo(buttonPos.x + 6, buttonPos.y + 6);
                ctx.moveTo(buttonPos.x + 6, buttonPos.y - 6);
                ctx.lineTo(buttonPos.x - 6, buttonPos.y + 6);
                ctx.stroke();
            }
        }

        // --- FUNCIONES DE CONTROLES ---
        function selectColor(e) {
            if (e.target.classList.contains('color-swatch')) {
                colorPalette.querySelectorAll('.color-swatch').forEach(swatch => swatch.classList.remove('selected'));
                e.target.classList.add('selected');
                currentColor = e.target.dataset.color;
            }
        }

        function downloadImage() {
            hoveredMeasurementIndex = -1; // Ocultar el botón de eliminar antes de descargar
            redrawCanvas();
            const link = document.createElement('a');
            link.download = 'arelyshop-medidas.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
        }
        
        function resetMeasurements() {
            measurements = [];
            hoveredMeasurementIndex = -1;
            redrawCanvas();
        }

        // --- INICIAR LA APLICACIÓN ---
        init();
    </script>
</body>
</html>

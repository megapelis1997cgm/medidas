<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Herramienta de Medición de Productos - ArelyShop</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f1f5f9; /* slate-100 */
        }
        #canvas-container {
            width: 100%;
            max-width: 600px;
            aspect-ratio: 1 / 1;
            border: 3px dashed #cbd5e1; /* slate-300 */
            transition: border-color 0.3s, background-color 0.3s;
        }
        #canvas-container.drag-over {
            border-color: #3b82f6; /* blue-500 */
            background-color: #eff6ff; /* blue-50 */
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        .color-swatch {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid transparent;
            transition: border-color 0.2s;
        }
        .color-swatch.selected {
            border-color: #3b82f6; /* blue-500 */
            box-shadow: 0 0 0 2px white;
        }
        #modal {
            background-color: rgba(0, 0, 0, 0.5);
        }
        .tool-btn {
            transition: background-color 0.2s, color 0.2s;
        }
        .tool-btn.active {
            background-color: #3b82f6; /* blue-600 */
            color: white;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col">

    <!-- Header -->
    <header class="bg-slate-900 p-4 shadow-md">
        <div class="max-w-4xl mx-auto flex justify-center">
            <img src="https://dcdn-us.mitiendanube.com/stores/004/546/736/themes/common/logo-660776128-1736645739-9bb5db1715d3b799cdf782b0f0815d541736645739.webp?0" alt="Logo ArelyShop" class="h-12" onerror="this.onerror=null; this.src='https://placehold.co/200x50/0f172a/ffffff?text=ArelyShop';">
        </div>
    </header>

    <!-- Contenido principal -->
    <main class="flex-grow container mx-auto p-4 md:p-8 flex flex-col items-center">
        <div class="w-full max-w-5xl flex flex-col lg:flex-row gap-8">
            <!-- Columna de Controles -->
            <div class="w-full lg:w-1/3 space-y-6">
                <div class="bg-white p-6 rounded-lg shadow-md">
                    <h2 class="text-xl font-bold text-slate-800 mb-4">1. Cargar Imagen</h2>
                    <label for="image-loader" class="w-full inline-block text-center bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 transition cursor-pointer">
                        Seleccionar Foto
                    </label>
                    <input type="file" id="image-loader" class="hidden" accept="image/*">
                </div>

                <!-- Selector de Herramientas -->
                <div class="bg-white p-6 rounded-lg shadow-md">
                    <h2 class="text-xl font-bold text-slate-800 mb-4">2. Herramientas</h2>
                    <div class="flex rounded-md shadow-sm">
                        <button id="tool-measure" class="tool-btn active w-1/2 p-2 border border-slate-300 rounded-l-lg">Medir</button>
                        <button id="tool-brush" class="tool-btn w-1/2 p-2 border-t border-b border-r border-slate-300 rounded-r-lg">Pincel</button>
                    </div>
                </div>
                
                <!-- Controles de Medición -->
                <div id="measure-controls" class="bg-white p-6 rounded-lg shadow-md space-y-4">
                    <h3 class="text-lg font-semibold text-slate-700">Color de Medida</h3>
                    <div id="color-palette" class="flex justify-center gap-4">
                        <div class="color-swatch selected" style="background-color: #000000;" data-color="#000000"></div>
                        <div class="color-swatch" style="background-color: #ef4444;" data-color="#ef4444"></div>
                        <div class="color-swatch" style="background-color: #3b82f6;" data-color="#3b82f6"></div>
                        <div class="color-swatch" style="background-color: #22c55e;" data-color="#22c55e"></div>
                        <div class="color-swatch" style="background-color: #f97316;" data-color="#f97316"></div>
                    </div>
                </div>

                <!-- Controles del Pincel -->
                <div id="brush-controls" class="bg-white p-6 rounded-lg shadow-md space-y-4 hidden">
                    <div>
                        <h3 class="text-lg font-semibold text-slate-700 mb-2">Color de Pincel</h3>
                        <input type="color" id="brush-color-picker" value="#FFFFFF" class="w-full h-10 p-1 border border-slate-300 rounded-md cursor-pointer">
                    </div>
                    <div>
                        <label for="brush-size-slider" class="text-lg font-semibold text-slate-700">Tamaño: <span id="brush-size-value">20</span>px</label>
                        <input type="range" id="brush-size-slider" min="1" max="100" value="20" class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer">
                    </div>
                </div>

                <div class="bg-white p-6 rounded-lg shadow-md">
                    <h2 class="text-xl font-bold text-slate-800 mb-4">3. Acciones</h2>
                    <div class="space-y-4">
                        <button id="download-btn" class="w-full bg-emerald-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-emerald-700 transition disabled:bg-slate-400 disabled:cursor-not-allowed" disabled>
                            Descargar Imagen
                        </button>
                        <button id="reset-btn" class="w-full bg-red-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-700 transition disabled:bg-slate-400 disabled:cursor-not-allowed" disabled>
                            Limpiar Todo
                        </button>
                    </div>
                </div>
            </div>

            <!-- Columna del Canvas -->
            <div class="w-full lg:w-2/3 flex flex-col items-center">
                <div id="canvas-container" class="bg-white rounded-lg shadow-md flex items-center justify-center relative">
                    <canvas id="canvas" width="1000" height="1000"></canvas>
                    <div id="placeholder-text" class="absolute text-center text-slate-400 p-4 pointer-events-none">
                        <!-- *** TEXTO ACTUALIZADO *** -->
                        <p class="text-lg font-semibold">Haz clic o arrastra una imagen aquí</p>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Modal para medida -->
    <div id="modal" class="fixed inset-0 z-50 items-center justify-center hidden">
        <div class="bg-white p-6 rounded-lg shadow-xl w-80">
            <h3 class="text-lg font-bold mb-4">Ingresar Medida</h3>
            <input type="text" id="measurement-input" class="w-full border border-slate-300 rounded-md p-2 mb-4" placeholder="Ej: 25 cm">
            <div class="flex justify-end gap-2">
                <button id="cancel-btn" class="px-4 py-2 bg-slate-200 text-slate-800 rounded-md hover:bg-slate-300">Cancelar</button>
                <button id="submit-btn" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700">Aceptar</button>
            </div>
        </div>
    </div>

    <script>
        // --- ELEMENTOS DEL DOM ---
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const imageLoader = document.getElementById('image-loader');
        const downloadBtn = document.getElementById('download-btn');
        const resetBtn = document.getElementById('reset-btn');
        const canvasContainer = document.getElementById('canvas-container');
        const placeholderText = document.getElementById('placeholder-text');
        const colorPalette = document.getElementById('color-palette');
        const modal = document.getElementById('modal');
        const measurementInput = document.getElementById('measurement-input');
        const submitBtn = document.getElementById('submit-btn');
        const cancelBtn = document.getElementById('cancel-btn');
        const toolMeasureBtn = document.getElementById('tool-measure');
        const toolBrushBtn = document.getElementById('tool-brush');
        const measureControls = document.getElementById('measure-controls');
        const brushControls = document.getElementById('brush-controls');
        const brushColorPicker = document.getElementById('brush-color-picker');
        const brushSizeSlider = document.getElementById('brush-size-slider');
        const brushSizeValue = document.getElementById('brush-size-value');

        // --- ESTADO DE LA APLICACIÓN ---
        let image = null;
        let measurements = [];
        let brushStrokes = [];
        let currentPath = [];
        let isDrawing = false;
        let startX, startY, endX, endY;
        let measureColor = '#000000';
        let hoveredMeasurementIndex = -1;
        let currentTool = 'measure';
        let brushColor = '#FFFFFF';
        let brushSize = 20;
        let lastBrushPoint = null;
        let currentMousePos = null;

        // --- CONSTANTES ---
        const CANVAS_WIDTH = 1000;
        const CANVAS_HEIGHT = 1000;
        const TEXT_SIZE = 30;
        const LINE_WIDTH = 3;
        const CAP_LENGTH = 15;
        const DELETE_BUTTON_RADIUS = 15;

        // --- INICIALIZACIÓN ---
        function init() {
            setupEventListeners();
            clearCanvas();
        }

        function setupEventListeners() {
            imageLoader.addEventListener('change', handleImageUpload);
            canvasContainer.addEventListener('dragover', handleDragOver);
            canvasContainer.addEventListener('dragleave', handleDragLeave);
            canvasContainer.addEventListener('drop', handleDrop);
            // *** NUEVO: Evento de clic en el contenedor del canvas ***
            canvasContainer.addEventListener('click', handleCanvasContainerClick);
            
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseleave', handleMouseLeave);
            
            downloadBtn.addEventListener('click', downloadImage);
            resetBtn.addEventListener('click', clearAll);
            
            colorPalette.addEventListener('click', selectMeasureColor);
            toolMeasureBtn.addEventListener('click', () => switchTool('measure'));
            toolBrushBtn.addEventListener('click', () => switchTool('brush'));
            brushColorPicker.addEventListener('input', (e) => brushColor = e.target.value);
            brushSizeSlider.addEventListener('input', (e) => {
                brushSize = e.target.value;
                brushSizeValue.textContent = brushSize;
                redrawCanvas();
            });

            submitBtn.addEventListener('click', submitMeasurement);
            cancelBtn.addEventListener('click', cancelMeasurement);
            measurementInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') submitMeasurement();
                if (e.key === 'Escape') cancelMeasurement();
            });
        }
        
        function switchTool(tool) {
            currentTool = tool;
            lastBrushPoint = null;
            if (tool === 'measure') {
                toolMeasureBtn.classList.add('active');
                toolBrushBtn.classList.remove('active');
                measureControls.style.display = 'block';
                brushControls.style.display = 'none';
            } else { // brush
                toolBrushBtn.classList.add('active');
                toolMeasureBtn.classList.remove('active');
                brushControls.style.display = 'block';
                measureControls.style.display = 'none';
            }
            updateCursor();
        }

        function updateCursor() {
            if (!image) { canvas.style.cursor = 'pointer'; return; } // Cursor de puntero si no hay imagen
            if (currentTool === 'measure') {
                canvas.style.cursor = hoveredMeasurementIndex !== -1 ? 'pointer' : 'crosshair';
            } else { // brush
                canvas.style.cursor = 'none';
            }
        }
        
        // --- MANEJO DE IMAGEN ---
        function handleImageUpload(e) { const file = e.target.files[0]; if (file) loadImage(file); }
        function handleDragOver(e) { e.preventDefault(); e.stopPropagation(); canvasContainer.classList.add('drag-over'); }
        function handleDragLeave(e) { e.preventDefault(); e.stopPropagation(); canvasContainer.classList.remove('drag-over'); }
        function handleDrop(e) {
            e.preventDefault(); e.stopPropagation(); canvasContainer.classList.remove('drag-over');
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('image/')) loadImage(file);
        }
        
        // *** NUEVO: Función para manejar el clic en el contenedor ***
        function handleCanvasContainerClick() {
            if (!image) {
                imageLoader.click();
            }
        }

        function loadImage(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                image = new Image();
                image.onload = () => {
                    clearAll();
                    enableButtons();
                    redrawCanvas();
                };
                image.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
        
        function enableButtons() {
            downloadBtn.disabled = false;
            resetBtn.disabled = false;
            placeholderText.style.display = 'none';
            updateCursor();
        }

        // --- LÓGICA DE EVENTOS DEL CANVAS ---
        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            return { x: (e.clientX - rect.left) * (CANVAS_WIDTH / rect.width), y: (e.clientY - rect.top) * (CANVAS_HEIGHT / rect.height) };
        }

        function handleMouseDown(e) {
            if (!image) return;
            // Prevenir que el clic en el canvas active la subida de archivos si ya hay una imagen
            e.stopPropagation(); 
            const pos = getMousePos(e);
            
            if (currentTool === 'measure') {
                if (hoveredMeasurementIndex !== -1) {
                    // Si se hace clic en un botón de borrar, manejarlo aquí
                    const m = measurements[hoveredMeasurementIndex];
                    const buttonPos = getDeleteButtonPosition(m);
                    if (Math.hypot(pos.x - buttonPos.x, pos.y - buttonPos.y) <= DELETE_BUTTON_RADIUS) {
                        measurements.splice(hoveredMeasurementIndex, 1);
                        hoveredMeasurementIndex = -1;
                        redrawCanvas();
                        return;
                    }
                }
                isDrawing = true;
                startX = pos.x;
                startY = pos.y;
            } else { // brush
                if (e.shiftKey) {
                    if (lastBrushPoint) {
                        brushStrokes.push({ points: [lastBrushPoint, pos], color: brushColor, size: brushSize });
                        redrawCanvas();
                    }
                    lastBrushPoint = pos;
                } else {
                    isDrawing = true;
                    lastBrushPoint = null;
                    currentPath = [pos];
                }
            }
        }

        function handleMouseMove(e) {
            currentMousePos = getMousePos(e);
            if (isDrawing) {
                if (currentTool === 'measure') {
                    let currentX = currentMousePos.x; let currentY = currentMousePos.y;
                    if (e.shiftKey) {
                        const dx = Math.abs(currentX - startX); const dy = Math.abs(currentY - startY);
                        if (dx > dy) currentY = startY; else currentX = startX;
                    }
                    endX = currentX; endY = currentY;
                } else { // brush
                    currentPath.push(currentMousePos);
                }
                redrawCanvas();
            } else {
                if(currentTool === 'measure') {
                    // Lógica de HOVER para medidas
                    let newHoverIndex = -1;
                    for (let i = measurements.length - 1; i >= 0; i--) {
                        const m = measurements[i];
                        const buttonPos = getDeleteButtonPosition(m);
                        if (Math.hypot(currentMousePos.x - buttonPos.x, currentMousePos.y - buttonPos.y) <= DELETE_BUTTON_RADIUS) {
                            newHoverIndex = i;
                            break;
                        }
                        if (pointToLineSegmentDistance(currentMousePos.x, currentMousePos.y, m.startX, m.startY, m.endX, m.endY) < 10) {
                            newHoverIndex = i;
                            break;
                        }
                    }
                    if (newHoverIndex !== hoveredMeasurementIndex) {
                        hoveredMeasurementIndex = newHoverIndex;
                        updateCursor();
                    }
                }
                redrawCanvas();
            }
        }

        function handleMouseUp() {
            if (!isDrawing) return;
            isDrawing = false;
            if (currentTool === 'measure') {
                if (startX !== endX || startY !== endY) showModal();
            } else { // brush
                if (currentPath.length > 1) {
                    brushStrokes.push({ points: currentPath, color: brushColor, size: brushSize });
                    lastBrushPoint = currentPath[currentPath.length - 1];
                }
                currentPath = [];
            }
        }
        
        function handleMouseLeave() {
            currentMousePos = null;
            if (isDrawing) {
                isDrawing = false;
                if (currentTool === 'brush' && currentPath.length > 1) {
                    brushStrokes.push({ points: currentPath, color: brushColor, size: brushSize });
                }
                currentPath = [];
            }
            redrawCanvas();
        }

        function pointToLineSegmentDistance(px, py, x1, y1, x2, y2) {
            const l2 = (x2 - x1) ** 2 + (y2 - y1) ** 2;
            if (l2 === 0) return Math.hypot(px - x1, py - y1);
            let t = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / l2;
            t = Math.max(0, Math.min(1, t));
            const closestX = x1 + t * (x2 - x1); const closestY = y1 + t * (y2 - y1);
            return Math.hypot(px - closestX, py - closestY);
        }

        // --- MODAL ---
        function showModal() { modal.style.display = 'flex'; measurementInput.value = ''; measurementInput.focus(); }
        function hideModal() { modal.style.display = 'none'; }
        function submitMeasurement() {
            const text = measurementInput.value.trim();
            if (text) measurements.push({ startX, startY, endX, endY, color: measureColor, text });
            hideModal();
            redrawCanvas();
        }
        function cancelMeasurement() { hideModal(); redrawCanvas(); }

        // --- FUNCIONES DE RENDERIZADO ---
        function clearCanvas() {
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
             if (!image) placeholderText.style.display = 'block';
             updateCursor();
        }
        
        function redrawCanvas() {
            clearCanvas();
            if (image) {
                const hRatio = CANVAS_WIDTH / image.width; const vRatio = CANVAS_HEIGHT / image.height;
                const ratio = Math.min(hRatio, vRatio);
                const centerShiftX = (CANVAS_WIDTH - image.width * ratio) / 2;
                const centerShiftY = (CANVAS_HEIGHT - image.height * ratio) / 2;
                ctx.drawImage(image, 0, 0, image.width, image.height, centerShiftX, centerShiftY, image.width * ratio, image.height * ratio);
            }
            
            brushStrokes.forEach(drawBrushStroke);
            if (isDrawing && currentTool === 'brush' && currentPath.length > 0) {
                 drawBrushStroke({ points: currentPath, color: brushColor, size: brushSize });
            }

            measurements.forEach((m, index) => drawMeasurementLine(m, index));
            
            if (currentTool === 'brush' && currentMousePos) {
                drawBrushVisualizer(currentMousePos);
            }
        }
        
        function drawBrushStroke(stroke) {
            ctx.strokeStyle = stroke.color;
            ctx.lineWidth = stroke.size;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
            for (let i = 1; i < stroke.points.length; i++) {
                ctx.lineTo(stroke.points[i].x, stroke.points[i].y);
            }
            ctx.stroke();
        }
        
        function drawBrushVisualizer(pos) {
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, brushSize / 2, 0, Math.PI * 2);
            ctx.stroke();
        }

        function getDeleteButtonPosition(m) {
             const angle = Math.atan2(m.endY - m.startY, m.endX - m.startX);
             const perpAngle = angle + Math.PI / 2;
             return { x: m.endX + (CAP_LENGTH + 5) * Math.cos(perpAngle), y: m.endY + (CAP_LENGTH + 5) * Math.sin(perpAngle) };
        }

        function drawMeasurementLine(m, index) {
            const { startX, startY, endX, endY, color, text = '' } = m;
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = (index === hoveredMeasurementIndex && currentTool === 'measure') ? LINE_WIDTH + 2 : LINE_WIDTH;
            ctx.font = `bold ${TEXT_SIZE}px Inter`;
            
            const angle = Math.atan2(endY - startY, endX - startX);
            const perpAngle = angle + Math.PI / 2;

            const cap1_x1 = startX + CAP_LENGTH * Math.cos(perpAngle); const cap1_y1 = startY + CAP_LENGTH * Math.sin(perpAngle);
            const cap1_x2 = startX - CAP_LENGTH * Math.cos(perpAngle); const cap1_y2 = startY - CAP_LENGTH * Math.sin(perpAngle);
            const cap2_x1 = endX + CAP_LENGTH * Math.cos(perpAngle); const cap2_y1 = endY + CAP_LENGTH * Math.sin(perpAngle);
            const cap2_x2 = endX - CAP_LENGTH * Math.cos(perpAngle); const cap2_y2 = endY - CAP_LENGTH * Math.sin(perpAngle);

            ctx.beginPath();
            if (text) {
                const textMetrics = ctx.measureText(text);
                const textWidth = textMetrics.width + 10;
                const lineLength = Math.hypot(endX - startX, endY - startY);
                const segmentLength = (lineLength - textWidth) / 2;
                if (segmentLength > 0) {
                    const gapStartX = startX + segmentLength * Math.cos(angle); const gapStartY = startY + segmentLength * Math.sin(angle);
                    const gapEndX = endX - segmentLength * Math.cos(angle); const gapEndY = endY - segmentLength * Math.sin(angle);
                    ctx.moveTo(startX, startY); ctx.lineTo(gapStartX, gapStartY);
                    ctx.moveTo(gapEndX, gapEndY); ctx.lineTo(endX, endY);
                }
            } else {
                ctx.moveTo(startX, startY); ctx.lineTo(endX, endY);
            }
            ctx.moveTo(cap1_x1, cap1_y1); ctx.lineTo(cap1_x2, cap1_y2);
            ctx.moveTo(cap2_x1, cap2_y1); ctx.lineTo(cap2_x2, cap2_y2);
            ctx.stroke();

            if (text) {
                const midX = (startX + endX) / 2; const midY = (startY + endY) / 2;
                ctx.save();
                ctx.translate(midX, midY);
                ctx.rotate(angle);
                if (angle > Math.PI / 2 || angle < -Math.PI / 2) ctx.rotate(Math.PI);
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText(text, 0, 0); 
                ctx.restore();
            }

            if (index === hoveredMeasurementIndex && currentTool === 'measure') {
                const buttonPos = getDeleteButtonPosition(m);
                ctx.beginPath();
                ctx.arc(buttonPos.x, buttonPos.y, DELETE_BUTTON_RADIUS, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(239, 68, 68, 0.9)';
                ctx.fill();
                ctx.strokeStyle = 'white'; ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(buttonPos.x - 6, buttonPos.y - 6); ctx.lineTo(buttonPos.x + 6, buttonPos.y + 6);
                ctx.moveTo(buttonPos.x + 6, buttonPos.y - 6); ctx.lineTo(buttonPos.x - 6, buttonPos.y + 6);
                ctx.stroke();
            }
        }

        // --- FUNCIONES DE CONTROLES ---
        function selectMeasureColor(e) {
            if (e.target.classList.contains('color-swatch')) {
                colorPalette.querySelectorAll('.color-swatch').forEach(swatch => swatch.classList.remove('selected'));
                e.target.classList.add('selected');
                measureColor = e.target.dataset.color;
            }
        }

        function downloadImage() {
            hoveredMeasurementIndex = -1;
            currentMousePos = null;
            redrawCanvas();
            const link = document.createElement('a');
            link.download = 'arelyshop-medidas.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
        }
        
        function clearAll() {
            measurements = [];
            brushStrokes = [];
            hoveredMeasurementIndex = -1;
            lastBrushPoint = null;
            redrawCanvas();
        }

        // --- INICIAR LA APLICACIÓN ---
        init();
    </script>
</body>
</html>
